#!/usr/bin/env python

### Overview
###
###     Code generator to generate hpp/cpp files which contains
###     an std::array that contains the binary data from the input
###     file.  Typical usage would be generate a bitmap font file
###     to compile within an image or shader source code to embed
###     within an image.  In the case of embedding text, such
###     as a shader source file, ensure to pass the --null switch
###     to this script to append the null terminator at the end
###     of the array output as the input file is read as binary.
###
###     A namespace option also exists to wrap the generated
###     output array within the namespace.  This will also
###     the change the include header of the source file.  So
###     if the output name is 'foo' and the namespace is 'bar'
###     then in foo.cpp will have a '#include <bar/foo.hpp>'.
###

import os
import argparse

parser = argparse.ArgumentParser(
    description='''Generate C++ cpp/hpp files containing an 
                   array of binary data from an input file.''')

parser.add_argument('infile', metavar='IN_FILE',
                    help='input file to generate from')
parser.add_argument('outname', metavar='OUT_NAME',
                    help='basename of output files')
parser.add_argument('--null', action='store_true',
                    help='Add a null termination byte to the end of the output')
parser.add_argument('--namespace', help='include a namespace')

args = parser.parse_args()

with open(args.infile, mode='rb') as source:
    notice = '\n// This file was generated by codegen.py\n'
    outhpp = args.outname + '.hpp'
    outcpp = args.outname + '.cpp'
    size   = source.seek(0, 2)

    if args.null:
        size   += 1
        notice += '// --null set -- 0x00 is appended at the end of the array\n\n'
    else:
        notice += '\n'

    source.seek(0, 0)

    with open(outhpp, mode='w') as hpp:
        hpp.write('#ifndef __' + args.outname.upper() + '_HPP__\n')
        hpp.write('#define __' + args.outname.upper() + '_HPP__\n')
        hpp.write(notice)
        hpp.write('#include <array>\n\n')
        if args.namespace:
            hpp.write('namespace ' + args.namespace + ' {\n\n')
        hpp.write('extern std::array<char, ' + str(size) + '> ' + args.outname + ';\n\n')
        if args.namespace:
            hpp.write('} // end namespace ' + args.namespace + '\n\n')
        hpp.write('#endif // __' + args.outname.upper() + '_HPP__\n')

    with open(outcpp, mode='w') as cpp:
        cpp.write(notice)
        if args.namespace:
            cpp.write('#include <' + args.namespace + '/' + outhpp + '>\n\n')
        else:
            cpp.write('#include "' + outhpp + '"\n\n')

        cpp.write('std::array<char, ' + str(size) + '> ')
        if args.namespace:
            cpp.write(args.namespace + '::')
        cpp.write(args.outname + ' = {')

        count = 0
        for byte in source.read(size):
            if count % 16 == 0:
                cpp.write('\n    ')
                count = 0 
            elif count % 4 == 0:
                cpp.write('  ')
            count += 1

            out = hex(byte)
            if len(out) == 3:
                cpp.write('0x0' + out[2] + ',')     # pad an inner zero
            else:
                cpp.write(out + ',')

        if args.null:
            cpp.write('0x00')

        cpp.write('\n};\n')
